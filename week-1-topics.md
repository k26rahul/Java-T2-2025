L1 Introduction

Variables: Name, type, values
Variables identity memory locations
Interpreter vs compiler
Imperative vs declarative
High level, low level languages
Abstraction
Registers in CPU

L2 Types

Static vs dynamic typing
Static analysis, catching bugs early
Compile time errors vs runtime errors
Halting problem

L3 Memory Management

Activation records as stack
Control link points to previous act record
Return link tells where to store value
Scope (is it visible) and lifetime (does it exist) of a variable
Parameters vs arguments
Call by value vs call by reference
Heap vs stack memory
Garbage collection

L4 Abstraction and Modularity

Abstraction means hiding implementation
Hide what? Complex logic, internal data representation
Modularity means complex tasks broken into simpler steps

L5 OOP

Queues, Stacks, Deques
Objects encapsulate data and functionality together
Abstraction: hide implementation details
Subtyping: Hierarchy of types
Dynamic lookup: Overriding parent methods, which method to run decided at runtime
Inheritance: Reuse of parent's implementations
Interfaces, Classes

L6 Classes

Template/Blueprint for objects
Objects are instances of classes
Hierarchy of classes to implement subtyping and inheritance
Data privacy: private instance variables
